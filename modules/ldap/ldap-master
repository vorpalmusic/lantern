#!/usr/bin/env bash
# ldap-master — LDAP/AD enumeration using ldapsearch (anonymous bind only)
# Usage:
#   ldap-master OUTDIR TARGET [PORTS]
#
# Behavior:
#   - Ports: if PORTS is provided, treat it as comma-separated and keep only 389,636,3268,3269.
#            If omitted, default to 389.
#   - For each port:
#       * Attempt anonymous bind to RootDSE.
#       * Dump RootDSE and supported capabilities.
#       * Derive Base DN from defaultNamingContext (or namingContexts).
#       * Enumerate:
#           - Domain object (Base DN, objectClass, etc.)
#           - Users (non-computer) and key attributes
#           - Groups and memberships
#           - Computers (hostnames, OS, SPNs)
#           - SPN-bearing accounts
#           - “Interesting” admin-ish accounts
#           - Full objectClass=* (all LDAP-visible objects)
#       * Artifacts under OUTDIR/ldap/<PORT>/:
#           rootdse.txt
#           basedn.txt
#           domain.txt
#           users.txt
#           groups.txt
#           computers.txt
#           spn-accounts.txt
#           interesting.txt
#           users-classified.txt        (HUMAN/SERVICE/SYSTEM + state + ASREP)
#           groups-priv.txt             (high-priv group summary)
#           all-objects.txt             (raw objectClass=* dump)
#           extra-accounts.txt          (accounts only seen via objectClass=* search)
#           summary.txt                 (human-friendly, high-signal view)
#
#   - Requires: ldapsearch (ldap-utils)

ROOTDIR="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")/../.." >/dev/null 2>&1 && pwd)"
. "$ROOTDIR/lib/colors"

SCRIPT_NAME="${0##*/}"

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME OUTDIR TARGET [PORTS]

Positional:
  OUTDIR   Target output directory (per-host root used by Lantern)
  TARGET   IP or hostname
  PORTS    Optional comma-separated LDAP ports (e.g. "389", "389,636,3268,3269")
           If omitted, defaults to 389.
EOF
  exit 1
}

OUTDIR="${1:-}"
TARGET="${2:-}"
PORTS_ARG="${3:-}"

if [ -z "$OUTDIR" ] || [ -z "$TARGET" ]; then
  usage
fi

if ! command -v ldapsearch >/dev/null 2>&1; then
  echo -e "${yellow}[!]${end} ${purple}ldapsearch not found (install ldap-utils); skipping LDAP module.${end}"
  exit 0
fi

mkdir -p "$OUTDIR/ldap"

echo -e "${yellow}[*]${end} ${purple}LDAP module started for target${end} ${blue}${TARGET}${end}"

# --- Ports: keep only LDAP-ish ones (389, 636, 3268, 3269) ---

ports=()

if [ -n "$PORTS_ARG" ]; then
  IFS=',' read -r -a raw_ports <<< "$PORTS_ARG"
  for p in "${raw_ports[@]}"; do
    p_clean="${p//[^0-9]/}"
    [ -z "$p_clean" ] && continue
    case "$p_clean" in
      389|636|3268|3269)
        ports+=("$p_clean")
        ;;
      *)
        # ignore others
        ;;
    esac
  done
fi

# Default to 389 if nothing usable was provided
if [ "${#ports[@]}" -eq 0 ]; then
  ports=(389)
fi

# --- Helper: port label + scheme ---

ldap_port_label() {
  local p="$1"
  case "$p" in
    389)  echo "LDAP (389)" ;;
    636)  echo "LDAPS (636)" ;;
    3268) echo "LDAP Global Catalog (3268)" ;;
    3269) echo "LDAPS Global Catalog (3269)" ;;
    *)    echo "LDAP-like on port $p" ;;
  esac
}

ldap_scheme_for_port() {
  local p="$1"
  case "$p" in
    636|3269) echo "ldaps" ;;
    *)        echo "ldap" ;;
  esac
}

# --- Helper: extract base DN from RootDSE ---

extract_basedn() {
  # $1: path to rootdse.txt
  local f="$1" dn=""
  if [ -s "$f" ]; then
    # Prefer defaultNamingContext
    dn="$(grep -m1 '^defaultNamingContext:' "$f" 2>/dev/null | sed 's/^defaultNamingContext:[[:space:]]*//')"
    if [ -z "$dn" ]; then
      # Fallback: namingContexts (first one)
      dn="$(grep -m1 '^namingContexts:' "$f" 2>/dev/null | sed 's/^namingContexts:[[:space:]]*//')"
    fi
  fi
  printf '%s\n' "$dn"
}

# --- Main per-port loop ---

for PORT in "${ports[@]}"; do
  LDAPDIR="$OUTDIR/ldap/$PORT"
  mkdir -p "$LDAPDIR"

  ROOTDSE_FILE="$LDAPDIR/rootdse.txt"
  BASEDN_FILE="$LDAPDIR/basedn.txt"
  DOMAIN_FILE="$LDAPDIR/domain.txt"
  USERS_FILE="$LDAPDIR/users.txt"
  GROUPS_FILE="$LDAPDIR/groups.txt"
  COMPUTERS_FILE="$LDAPDIR/computers.txt"
  SPN_FILE="$LDAPDIR/spn-accounts.txt"
  INTERESTING_FILE="$LDAPDIR/interesting.txt"
  CLASS_FILE="$LDAPDIR/users-classified.txt"
  PRIVGROUP_FILE="$LDAPDIR/groups-priv.txt"
  ALLOBJ_FILE="$LDAPDIR/all-objects.txt"
  EXTRA_ACCOUNTS_FILE="$LDAPDIR/extra-accounts.txt"
  KNOWN_SAM_FILE="$LDAPDIR/known-sam.txt"
  ALL_ACCOUNTS_RAW="$LDAPDIR/all-accounts-raw.txt"
  SUMMARY_FILE="$LDAPDIR/summary.txt"

  : >"$ROOTDSE_FILE"
  : >"$BASEDN_FILE"
  : >"$DOMAIN_FILE"
  : >"$USERS_FILE"
  : >"$GROUPS_FILE"
  : >"$COMPUTERS_FILE"
  : >"$SPN_FILE"
  : >"$INTERESTING_FILE"
  : >"$CLASS_FILE"
  : >"$PRIVGROUP_FILE"
  : >"$ALLOBJ_FILE"
  : >"$EXTRA_ACCOUNTS_FILE"
  : >"$KNOWN_SAM_FILE"
  : >"$ALL_ACCOUNTS_RAW"
  : >"$SUMMARY_FILE"

  port_label="$(ldap_port_label "$PORT")"
  scheme="$(ldap_scheme_for_port "$PORT")"
  url="${scheme}://${TARGET}:${PORT}"

  echo -e "${yellow}  [-]${end} ${purple}Enumerating LDAP on${end} ${blue}${TARGET}:${PORT}${end} ${purple}(${port_label})...${end}"

  anon_ok=0
  base_dn=""
  domain_name=""
  dc_host=""
  users_count=0
  groups_count=0
  computers_count=0
  spn_count=0
  interesting_count=0
  human_count=0
  service_count=0
  asrep_count=0
  extra_accounts_count=0

  # --- RootDSE / anonymous bind test ---

  ldapsearch -x \
    -H "$url" \
    -s base -b "" \
    -LLL \
    -o nettimeout=8 \
    -l 20 \
    '*' '+' >"$ROOTDSE_FILE" 2>/dev/null || true

  if [ -s "$ROOTDSE_FILE" ]; then
    anon_ok=1
    echo -e "${green}    [*] Anonymous LDAP bind succeeded on${end} ${blue}${TARGET}:${PORT}${end}"
  else
    anon_ok=0
    echo -e "${yellow}    [!] Anonymous LDAP bind failed or returned no data on${end} ${blue}${TARGET}:${PORT}${end}"
  fi

  # Extract base DN
  base_dn="$(extract_basedn "$ROOTDSE_FILE")"
  printf "%s\n" "${base_dn:-}" >"$BASEDN_FILE"

  # Derive domain name from base DN (e.g. DC=htb,DC=local -> htb.local)
  if [ -n "$base_dn" ]; then
    domain_name="$(echo "$base_dn" | sed 's/DC=//g;s/,/./g')"
  fi

  # DC hostname from RootDSE if present
  if [ -s "$ROOTDSE_FILE" ]; then
    dc_host="$(grep -m1 '^dnsHostName:' "$ROOTDSE_FILE" 2>/dev/null | sed 's/^dnsHostName:[[:space:]]*//')"
  fi

  if [ -n "$base_dn" ]; then
    echo -e "${yellow}    [*]${end} ${purple}Base DN detected:${end} ${blue}${base_dn}${end}"
  else
    echo -e "${yellow}    [!] No base DN derived from RootDSE; skipping deep LDAP searches on${end} ${blue}${TARGET}:${PORT}${end}"
  fi

  # If no base_dn, we still write a minimal summary and move on
  if [ -z "$base_dn" ]; then
    {
      echo "BASE DN:               <none>"
      echo "DOMAIN:                ${domain_name:-<unknown>}"
      echo "DC Host:               ${dc_host:-<unknown>}"
      echo -n "Anonymous Bind:        "
      [ "$anon_ok" -eq 1 ] && echo "YES" || echo "NO"
      echo
      echo "Users:                 0"
      echo "Groups:                0"
      echo "Computers:             0"
      echo "SPN Accounts:          0"
      echo
      echo "----------------------------"
      echo "[ Human Users ]"
      echo "  (no base DN; no user enumeration)"
      echo
      echo "[ Service Accounts ]"
      echo "  (no base DN; no service enumeration)"
      echo
      echo "[ SPN Accounts ]"
      echo "  (no base DN; no SPN enumeration)"
      echo
      echo "[ High-Privilege Groups ]"
      echo "  (no base DN; no group enumeration)"
      echo
      echo "[ Interesting Users ]"
      echo "  (no base DN; no heuristics)"
      echo
      echo "[ Additional Accounts (objectClass=* only) ]"
      echo "  (no base DN; no objectClass=* enumeration)"
      echo
      echo "[ Service Smells ]"
      echo "  Exchange:            unknown"
      echo
    } >"$SUMMARY_FILE"
    continue
  fi

  # --- Domain object info (base DN) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s base \
    -LLL \
    -o nettimeout=8 \
    -l 20 \
    "(objectClass=*)" \
    name distinguishedName objectClass \
    >"$DOMAIN_FILE" 2>/dev/null || true

  # --- Users (non-computer) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(&(objectCategory=person)(objectClass=user))" \
    dn sAMAccountName userPrincipalName displayName description \
    memberOf whenCreated whenChanged adminCount userAccountControl \
    >"$USERS_FILE" 2>/dev/null || true

  if [ -s "$USERS_FILE" ]; then
    users_count="$(grep -c '^dn: ' "$USERS_FILE" 2>/dev/null || true)"
    [ -z "$users_count" ] && users_count=0
  fi

  # --- Groups ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(objectClass=group)" \
    dn sAMAccountName name description member \
    >"$GROUPS_FILE" 2>/dev/null || true

  if [ -s "$GROUPS_FILE" ]; then
    groups_count="$(grep -c '^dn: ' "$GROUPS_FILE" 2>/dev/null || true)"
    [ -z "$groups_count" ] && groups_count=0
  fi

  # --- Computers ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(objectCategory=computer)" \
    dn sAMAccountName dNSHostName operatingSystem operatingSystemVersion \
    servicePrincipalName \
    >"$COMPUTERS_FILE" 2>/dev/null || true

  if [ -s "$COMPUTERS_FILE" ]; then
    computers_count="$(grep -c '^dn: ' "$COMPUTERS_FILE" 2>/dev/null || true)"
    [ -z "$computers_count" ] && computers_count=0
  fi

  # --- SPN-bearing accounts (for later roasting) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(servicePrincipalName=*)" \
    dn sAMAccountName userPrincipalName servicePrincipalName \
    >"$SPN_FILE" 2>/dev/null || true

  if [ -s "$SPN_FILE" ]; then
    spn_count="$(grep -c '^dn: ' "$SPN_FILE" 2>/dev/null || true)"
    [ -z "$spn_count" ] && spn_count=0
  fi

  # --- "Interesting" accounts (basic heuristics) ---
  : >"$INTERESTING_FILE"
  if [ -s "$USERS_FILE" ]; then
    # adminCount=1
    awk '
      BEGIN { RS=""; FS="\n" }
      /adminCount:[[:space:]]*1/ { print $0 "\n" }
    ' "$USERS_FILE" >>"$INTERESTING_FILE" 2>/dev/null || true

    # memberOf *Admins* etc.
    awk '
      BEGIN { RS=""; FS="\n" }
      /memberOf: .*Domain Admins|memberOf: .*Enterprise Admins|memberOf: .*Schema Admins/ { print $0 "\n" }
    ' "$USERS_FILE" >>"$INTERESTING_FILE" 2>/dev/null || true
  fi

  if [ -s "$INTERESTING_FILE" ]; then
    # Deduplicate interesting entries by dn
    awk '
      BEGIN { RS=""; FS="\n" }
      {
        dn="";
        for (i=1; i<=NF; i++) {
          if ($i ~ /^dn: /) { dn=$i; break }
        }
        if (dn != "" && !(dn in seen)) {
          seen[dn]=1;
          print $0 "\n";
        }
      }
    ' "$INTERESTING_FILE" >"$INTERESTING_FILE.tmp" 2>/dev/null || true
    mv "$INTERESTING_FILE.tmp" "$INTERESTING_FILE" 2>/dev/null || true
    interesting_count="$(grep -c '^dn: ' "$INTERESTING_FILE" 2>/dev/null || true)"
    [ -z "$interesting_count" ] && interesting_count=0
  fi

  # --- Classification helper: HUMAN / SERVICE / SYSTEM + enabled/disabled + ASREP flag ---

  classify_sam() {
    # args: sam, uac (may be empty)
    local sam_local="$1"
    local uac_local="$2"
    local sam_l uacv system state asrep type

    [ -z "$sam_local" ] && return 0

    sam_l="${sam_local,,}"
    uacv=0
    if [[ "$uac_local" =~ ^[0-9]+$ ]]; then
      uacv="$uac_local"
    fi

    # --- system / service / human classification ---
    system=0
    case "$sam_l" in
      guest|defaultaccount)
        system=1
        ;;
    esac
    [[ "$sam_l" == sm_* ]] && system=1
    [[ "$sam_l" == healthmailbox* ]] && system=1
    [[ "$sam_l" == msol_* ]] && system=1
    [[ "$sam_local" == *'$' ]] && system=1    # machine accounts ending with $

    # enabled / disabled based on userAccountControl
    state="unknown"
    if (( uacv > 0 )); then
      if (( uacv & 2 )); then
        state="disabled"
      else
        state="enabled"
      fi
    fi

    # AS-REP roastable? (DONT_REQ_PREAUTH 0x400000 = 4194304)
    asrep="NO"
    if (( uacv > 0 && (uacv & 4194304) != 0 )); then
      asrep="ASREP_ROASTABLE"
    fi

    type="HUMAN"
    if (( system )); then
      type="SYSTEM"
    else
      # service patterns, including svc-* etc.
      if [[ "$sam_l" == svc-*    || "$sam_l" == svc_*   || \
            "$sam_l" == sql*     || "$sam_l" == backup* || \
            "$sam_l" == app*     || "$sam_l" == service* || \
            "$sam_local" == '$'* ]]; then
        type="SERVICE"
      fi
    fi

    printf '%s|%s|%s|%s\n' "$type" "$sam_local" "$state" "$asrep" >>"$CLASS_FILE"
  }

  # --- Classify users from USERS_FILE ---
  human_count=0
  service_count=0
  asrep_count=0

  if [ -s "$USERS_FILE" ]; then
    : >"$CLASS_FILE"

    sam=""
    uac=""

    # Parse users.txt line-by-line
    while IFS= read -r line || [ -n "$line" ]; do
      case "$line" in
        dn:\ *)
          # new record starts -> finalize previous
          classify_sam "$sam" "$uac"
          sam=""
          uac=""
          ;;
        sAMAccountName:\ *)
          sam="${line#sAMAccountName: }"
          ;;
        userAccountControl:\ *)
          uac="${line#userAccountControl: }"
          ;;
      esac
    done <"$USERS_FILE"

    # finalize last record
    classify_sam "$sam" "$uac"

    if [ -s "$CLASS_FILE" ]; then
      human_count="$(grep -c '^HUMAN|' "$CLASS_FILE" 2>/dev/null || true)"
      service_count="$(grep -c '^SERVICE|' "$CLASS_FILE" 2>/dev/null || true)"
      asrep_count="$(grep -c 'ASREP_ROASTABLE' "$CLASS_FILE" 2>/dev/null || true)"

      [ -z "$human_count" ] && human_count=0
      [ -z "$service_count" ] && service_count=0
      [ -z "$asrep_count" ] && asrep_count=0
    fi
  fi

  # --- Full objectClass=* enumeration (windapsearch-style) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=15 \
    -l 90 \
    -z 5000 \
    "(objectClass=*)" \
    dn sAMAccountName objectClass \
    >"$ALLOBJ_FILE" 2>/dev/null || true

  # Build known sAMAccountName set from CLASS_FILE
  if [ -s "$CLASS_FILE" ]; then
    cut -d'|' -f2 "$CLASS_FILE" | sed '/^$/d' | sort -u >"$KNOWN_SAM_FILE" 2>/dev/null || true
  else
    : >"$KNOWN_SAM_FILE"
  fi

  # Extract all accounts from all-objects (sam|objectClasses), with CN fallback
  if [ -s "$ALLOBJ_FILE" ]; then
    awk '
      BEGIN { RS=""; FS="\n" }
      {
        sam=""; dn=""; ocs=""
        for (i=1; i<=NF; i++) {
          line=$i
          if (line ~ /^dn:[[:space:]]*/) {
            dn=line
            sub(/^dn:[[:space:]]*/, "", dn)
          } else if (line ~ /^sAMAccountName:[[:space:]]*/) {
            sam=line
            sub(/^sAMAccountName:[[:space:]]*/, "", sam)
          } else if (line ~ /^objectClass:[[:space:]]*/) {
            oc=line
            sub(/^objectClass:[[:space:]]*/, "", oc)
            if (ocs=="") { ocs=oc } else { ocs=ocs "," oc }
          }
        }
        # If sAMAccountName is hidden, derive from CN= in the DN
        if (sam == "" && dn != "") {
          cn = dn
          sub(/,.*/, "", cn)
          sub(/^[Cc][Nn]=/, "", cn)
          sam = cn
        }
        if (sam=="") next
        print sam "|" ocs
      }
    ' "$ALLOBJ_FILE" >"$ALL_ACCOUNTS_RAW" 2>/dev/null || true
  fi

  # Derive extra accounts: present in objectClass=* dump, but not in CLASS_FILE
  if [ -s "$ALL_ACCOUNTS_RAW" ]; then
    while IFS='|' read -r sam_oc sam_ocs; do
      sam_oc="${sam_oc:-}"
      [ -z "$sam_oc" ] && continue
      if ! grep -qxF "$sam_oc" "$KNOWN_SAM_FILE" 2>/dev/null; then
        echo "$sam_oc|${sam_ocs:-}" >>"$EXTRA_ACCOUNTS_FILE"
      fi
    done <"$ALL_ACCOUNTS_RAW"
  fi

  # Classify extra accounts (svc-alfresco etc.)
  # Only treat extras as accounts if:
  #   - objectClass is clearly user-like, OR
  #   - name is clearly svc-* (and objectClass is not a group/container/OU).
  extra_accounts_count=0
  if [ -s "$EXTRA_ACCOUNTS_FILE" ]; then
    while IFS='|' read -r extra_sam extra_ocs; do
      [ -z "$extra_sam" ] && continue

      # Normalize for checks
      ocs_l="$(printf '%s\n' "${extra_ocs:-}" | tr '[:upper:]' '[:lower:]')"
      sam_l="${extra_sam,,}"

      # Ignore obvious non-account object types (groups, OUs, containers)
      case "$ocs_l" in
        *group*|*organizationalunit*|*container*)
          continue
          ;;
      esac

      is_account=0

      # 1) objectClass says "user-like"
      case "$ocs_l" in
        *user*|*person*|*inetorgperson*|*organizationalperson*|*msds-groupmanagedserviceaccount*)
          is_account=1
          ;;
      esac

      # 2) Very conservative svc-* heuristic; samAccountName never has spaces,
      #    but we already filtered out group/OU/container objectClasses above.
      if [ "$is_account" -eq 0 ]; then
        if [[ "$sam_l" == svc-* || "$sam_l" == svc_* ]]; then
          is_account=1
        fi
      fi

      [ "$is_account" -eq 0 ] && continue

      # No userAccountControl here (we don't have it in the all-objects pass),
      # so state will be "unknown" in classify_sam.
      classify_sam "$extra_sam" ""
      extra_accounts_count=$((extra_accounts_count + 1))
    done <"$EXTRA_ACCOUNTS_FILE"
  fi

  # Recompute HUMAN/SERVICE/ASREP counters now that extras have been added
  if [ -s "$CLASS_FILE" ]; then
    human_count="$(grep -c '^HUMAN|' "$CLASS_FILE" 2>/dev/null || true)"
    service_count="$(grep -c '^SERVICE|' "$CLASS_FILE" 2>/dev/null || true)"
    asrep_count="$(grep -c 'ASREP_ROASTABLE' "$CLASS_FILE" 2>/dev/null || true)"
    [ -z "$human_count" ] && human_count=0
    [ -z "$service_count" ] && service_count=0
    [ -z "$asrep_count" ] && asrep_count=0
  fi

  # --- High-privilege group summary ---
  if [ -s "$GROUPS_FILE" ]; then
    awk '
      BEGIN { RS=""; FS="\n" }
      {
        sam=""; name=""; members=0
        for (i=1; i<=NF; i++) {
          line=$i
          if (line ~ /^sAMAccountName:[[:space:]]*/) { sam=line; sub(/^sAMAccountName:[[:space:]]*/, "", sam) }
          else if (line ~ /^name:[[:space:]]*/)      { name=line; sub(/^name:[[:space:]]*/, "", name) }
          else if (line ~ /^member:[[:space:]]*/)    { members++ }
        }
        if (sam=="" && name=="") next
        lname = tolower(name)
        lsam  = tolower(sam)
        gname = name
        if (gname=="") gname=sam

        grp=""
        if (lname ~ /domain admins/      || lsam ~ /domain admins/)      grp="Domain Admins"
        else if (lname ~ /enterprise admins/  || lsam ~ /enterprise admins/)  grp="Enterprise Admins"
        else if (lname ~ /^administrators$/   || lsam ~ /^administrators$/)   grp="Administrators"
        else if (lname ~ /backup operators/   || lsam ~ /backup operators/)   grp="Backup Operators"
        else if (lname ~ /account operators/  || lsam ~ /account operators/)  grp="Account Operators"

        if (grp != "") {
          printf "%s|%s|%d\n", grp, gname, members
        }
      }
    ' "$GROUPS_FILE" >"$PRIVGROUP_FILE" 2>/dev/null || true
  fi

  # --- Service smells (currently: Exchange only) ---
  exchange_smell="NO"
  if [ -s "$USERS_FILE" ]; then
    if grep -qi 'HealthMailbox\|SystemMailbox\|Microsoft Exchange' "$USERS_FILE" 2>/dev/null; then
      exchange_smell="YES"
    fi
  fi

  # --- Normalize counters to digits only for extra safety ---
  users_count="${users_count//[^0-9]/}"
  groups_count="${groups_count//[^0-9]/}"
  computers_count="${computers_count//[^0-9]/}"
  spn_count="${spn_count//[^0-9]/}"
  human_count="${human_count//[^0-9]/}"
  service_count="${service_count//[^0-9]/}"
  asrep_count="${asrep_count//[^0-9]/}"
  interesting_count="${interesting_count//[^0-9]/}"
  extra_accounts_count="${extra_accounts_count//[^0-9]/}"

  [ -z "$users_count" ] && users_count=0
  [ -z "$groups_count" ] && groups_count=0
  [ -z "$computers_count" ] && computers_count=0
  [ -z "$spn_count" ] && spn_count=0
  [ -z "$human_count" ] && human_count=0
  [ -z "$service_count" ] && service_count=0
  [ -z "$asrep_count" ] && asrep_count=0
  [ -z "$interesting_count" ] && interesting_count=0
  [ -z "$extra_accounts_count" ] && extra_accounts_count=0

  # --- Build human-friendly summary.txt ---

  {
    echo "BASE DN:               ${base_dn:-<none>}"
    echo "DOMAIN:                ${domain_name:-<unknown>}"
    echo "DC Host:               ${dc_host:-<unknown>}"
    echo -n "Anonymous Bind:        "
    [ "$anon_ok" -eq 1 ] && echo "YES" || echo "NO"
    echo

    if [ -s "$CLASS_FILE" ] && [ "$users_count" -gt 0 ]; then
      echo "Users:                 ${users_count} (human: ${human_count}, service: ${service_count})"
    else
      echo "Users:                 ${users_count}"
    fi
    echo "Groups:                ${groups_count}"
    echo "Computers:             ${computers_count}"
    echo "SPN Accounts:          ${spn_count}"
    echo "Extra accounts (objectClass=* only): ${extra_accounts_count}"
    echo
    echo "----------------------------"
    echo "[ Human Users ]"
  } >"$SUMMARY_FILE"

  if [ -s "$CLASS_FILE" ] && [ "$human_count" -gt 0 ]; then
    awk -F'|' '$1=="HUMAN"{ printf "  %-22s %s\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Service Accounts ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$CLASS_FILE" ] && [ "$service_count" -gt 0 ]; then
    awk -F'|' '$1=="SERVICE"{ printf "  %-22s %s\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ SPN Accounts ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$SPN_FILE" ] && [ "$spn_count" -gt 0 ]; then
    awk '
      BEGIN { RS=""; FS="\n" }
      {
        sam=""; spn_first=""
        for (i=1; i<=NF; i++) {
          line=$i
          if (line ~ /^sAMAccountName:[[:space:]]*/) {
            sam=line; sub(/^sAMAccountName:[[:space:]]*/, "", sam)
          } else if (line ~ /^servicePrincipalName:[[:space:]]*/ && spn_first=="") {
            spn_first=line; sub(/^servicePrincipalName:[[:space:]]*/, "", spn_first)
          }
        }
        if (sam != "") {
          if (spn_first == "") spn_first="-"
          printf "  %-22s %s\n", sam, spn_first
        }
      }
    ' "$SPN_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ High-Privilege Groups ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$PRIVGROUP_FILE" ]; then
    while IFS='|' read -r grp gname members; do
      [ -z "$grp" ] && continue
      printf "  %-22s members: %s\n" "$grp" "${members:-0}" >>"$SUMMARY_FILE"
    done <"$PRIVGROUP_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Interesting Users ]"
  } >>"$SUMMARY_FILE"

  if [ -s "$INTERESTING_FILE" ] && [ "$interesting_count" -gt 0 ]; then
    echo "  adminCount / admin-group heuristics:" >>"$SUMMARY_FILE"
    echo "    ${interesting_count} entries — see: $INTERESTING_FILE" >>"$SUMMARY_FILE"
  elif [ "$asrep_count" -gt 0 ]; then
    :
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi

  if [ -s "$CLASS_FILE" ] && [ "$asrep_count" -gt 0 ]; then
    echo >>"$SUMMARY_FILE"
    echo "  AS-REP roastable candidates:" >>"$SUMMARY_FILE"
    awk -F'|' '$4=="ASREP_ROASTABLE"{ printf "    %-20s (%s)\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Additional Accounts (objectClass=* only) ]"
  } >>"$SUMMARY_FILE"
  printed_extra=0
  if [ -s "$EXTRA_ACCOUNTS_FILE" ] && [ -s "$CLASS_FILE" ]; then
    while IFS='|' read -r extra_sam extra_ocs; do
      [ -z "$extra_sam" ] && continue
      typ="$(grep -m1 "|${extra_sam}|" "$CLASS_FILE" 2>/dev/null | cut -d'|' -f1)"
      # Only show extras we actually classified (HUMAN/SERVICE/SYSTEM).
      [ -z "$typ" ] && continue
      printf "  %-22s %s\n" "$extra_sam" "$typ" >>"$SUMMARY_FILE"
      printed_extra=1
    done <"$EXTRA_ACCOUNTS_FILE"
  fi
  if [ "$printed_extra" -eq 0 ]; then
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Service Smells ]"
    echo "  Exchange:            ${exchange_smell}"
    echo
  } >>"$SUMMARY_FILE"

  echo -e "${yellow}    [*]${end} ${purple}LDAP enumeration finished for${end} ${blue}${TARGET}:${PORT}${end} ${purple}(users: $users_count, groups: $groups_count, computers: $computers_count, SPNs: $spn_count)${end}"
done

echo -e "${yellow}[+]${end} ${purple}LDAP module finished for target${end} ${blue}${TARGET}${end}"
exit 0
