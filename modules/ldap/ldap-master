#!/usr/bin/env bash
# ldap-master — LDAP/AD enumeration using ldapsearch (anonymous bind only)
# Usage:
#   ldap-master OUTDIR TARGET [PORTS]
#
# Behavior:
#   - Ports: if PORTS is provided, treat it as comma-separated and keep only 389,636,3268,3269.
#            If omitted, default to 389.
#   - For each port:
#       * Attempt anonymous bind to RootDSE.
#       * Dump RootDSE and supported capabilities.
#       * Derive Base DN from defaultNamingContext (or namingContexts).
#       * Enumerate:
#           - Domain object (Base DN, objectClass, etc.)
#           - Users (non-computer) and key attributes
#           - Groups and memberships
#           - Computers (hostnames, OS, SPNs)
#           - SPN-bearing accounts
#           - “Interesting” admin-ish accounts
#           - Full objectClass=* (all LDAP-visible objects)
#       * Artifacts under OUTDIR/ldap/<PORT>/:
#           rootdse.txt
#           basedn.txt
#           domain.txt
#           users.txt
#           groups.txt
#           computers.txt
#           spn-accounts.txt
#           interesting.txt
#           users-classified.txt        (HUMAN/SERVICE/SYSTEM + state + ASREP)
#           groups-priv.txt             (high-priv group summary)
#           all-objects.txt             (raw objectClass=* dump)
#           extra-accounts.txt          (accounts only seen via objectClass=* search)
#           hidden-accounts.txt         (svc-* style extras only seen via all-objects)
#           summary.txt                 (human-friendly, high-signal view)
#
#   - Requires: ldapsearch (ldap-utils)

ROOTDIR="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")/../.." >/dev/null 2>&1 && pwd)"
. "$ROOTDIR/lib/colors"

SCRIPT_NAME="${0##*/}"

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME OUTDIR TARGET [PORTS]

Positional:
  OUTDIR   Target output directory (per-host root used by Lantern)
  TARGET   IP or hostname
  PORTS    Optional comma-separated LDAP ports (e.g. "389", "389,636,3268,3269")
           If omitted, defaults to 389.
EOF
  exit 1
}

OUTDIR="${1:-}"
TARGET="${2:-}"
PORTS_ARG="${3:-}"

if [ -z "$OUTDIR" ] || [ -z "$TARGET" ]; then
  usage
fi

if ! command -v ldapsearch >/dev/null 2>&1; then
  echo -e "${yellow}[!]${end} ${purple}ldapsearch not found (install ldap-utils); skipping LDAP module.${end}"
  exit 0
fi

mkdir -p "$OUTDIR/ldap"

echo -e "${yellow}[*]${end} ${purple}LDAP module started for target${end} ${blue}${TARGET}${end}"

# --- Ports: keep only LDAP-ish ones (389, 636, 3268, 3269) ---

ports=()

if [ -n "$PORTS_ARG" ]; then
  IFS=',' read -r -a raw_ports <<< "$PORTS_ARG"
  for p in "${raw_ports[@]}"; do
    p_clean="${p//[^0-9]/}"
    [ -z "$p_clean" ] && continue
    case "$p_clean" in
      389|636|3268|3269)
        ports+=("$p_clean")
        ;;
      *)
        # ignore others
        ;;
    esac
  done
fi

# Default to 389 if nothing usable was provided
if [ "${#ports[@]}" -eq 0 ]; then
  ports=(389)
fi

# --- Helper: port label + scheme ---

ldap_port_label() {
  local p="$1"
  case "$p" in
    389)  echo "LDAP (389)" ;;
    636)  echo "LDAPS (636)" ;;
    3268) echo "LDAP Global Catalog (3268)" ;;
    3269) echo "LDAPS Global Catalog (3269)" ;;
    *)    echo "LDAP-like on port $p" ;;
  esac
}

ldap_scheme_for_port() {
  local p="$1"
  case "$p" in
    636|3269) echo "ldaps" ;;
    *)        echo "ldap" ;;
  esac
}

# --- Helper: extract base DN from RootDSE ---

extract_basedn() {
  # $1: path to rootdse.txt
  local f="$1" dn=""
  if [ -s "$f" ]; then
    # Prefer defaultNamingContext
    dn="$(grep -m1 '^defaultNamingContext:' "$f" 2>/dev/null | sed 's/^defaultNamingContext:[[:space:]]*//')"
    if [ -z "$dn" ]; then
      # Fallback: namingContexts (first one)
      dn="$(grep -m1 '^namingContexts:' "$f" 2>/dev/null | sed 's/^namingContexts:[[:space:]]*//')"
    fi
  fi
  printf '%s\n' "$dn"
}

# --- Main per-port loop ---

for PORT in "${ports[@]}"; do
  LDAPDIR="$OUTDIR/ldap/$PORT"
  mkdir -p "$LDAPDIR"

  ROOTDSE_FILE="$LDAPDIR/rootdse.txt"
  BASEDN_FILE="$LDAPDIR/basedn.txt"
  DOMAIN_FILE="$LDAPDIR/domain.txt"
  USERS_FILE="$LDAPDIR/users.txt"
  GROUPS_FILE="$LDAPDIR/groups.txt"
  COMPUTERS_FILE="$LDAPDIR/computers.txt"
  SPN_FILE="$LDAPDIR/spn-accounts.txt"
  INTERESTING_FILE="$LDAPDIR/interesting.txt"
  CLASS_FILE="$LDAPDIR/users-classified.txt"
  PRIVGROUP_FILE="$LDAPDIR/groups-priv.txt"
  ALLOBJ_FILE="$LDAPDIR/all-objects.txt"
  EXTRA_ACCOUNTS_FILE="$LDAPDIR/extra-accounts.txt"
  KNOWN_SAM_FILE="$LDAPDIR/known-sam.txt"
  ALL_ACCOUNTS_RAW="$LDAPDIR/all-accounts-raw.txt"
  HIDDEN_FILE="$LDAPDIR/hidden-accounts.txt"
  SUMMARY_FILE="$LDAPDIR/summary.txt"

  : >"$ROOTDSE_FILE"
  : >"$BASEDN_FILE"
  : >"$DOMAIN_FILE"
  : >"$USERS_FILE"
  : >"$GROUPS_FILE"
  : >"$COMPUTERS_FILE"
  : >"$SPN_FILE"
  : >"$INTERESTING_FILE"
  : >"$CLASS_FILE"
  : >"$PRIVGROUP_FILE"
  : >"$ALLOBJ_FILE"
  : >"$EXTRA_ACCOUNTS_FILE"
  : >"$KNOWN_SAM_FILE"
  : >"$ALL_ACCOUNTS_RAW"
  : >"$HIDDEN_FILE"
  : >"$SUMMARY_FILE"

  port_label="$(ldap_port_label "$PORT")"
  scheme="$(ldap_scheme_for_port "$PORT")"
  url="${scheme}://${TARGET}:${PORT}"

  echo -e "${yellow}  [-]${end} ${purple}Enumerating LDAP on${end} ${blue}${TARGET}:${PORT}${end} ${purple}(${port_label})...${end}"

  anon_ok=0
  base_dn=""
  domain_name=""
  dc_host=""
  users_count=0
  groups_count=0
  computers_count=0
  spn_count=0
  interesting_count=0
  human_count=0
  service_count=0
  asrep_count=0
  extra_accounts_count=0

  # --- RootDSE / anonymous bind test ---

  ldapsearch -x \
    -H "$url" \
    -s base -b "" \
    -LLL \
    -o nettimeout=8 \
    -l 20 \
    '*' '+' >"$ROOTDSE_FILE" 2>/dev/null || true

  if [ -s "$ROOTDSE_FILE" ]; then
    anon_ok=1
    echo -e "${green}    [*] Anonymous LDAP bind succeeded on${end} ${blue}${TARGET}:${PORT}${end}"
  else
    anon_ok=0
    echo -e "${yellow}    [!] Anonymous LDAP bind failed or returned no data on${end} ${blue}${TARGET}:${PORT}${end}"
  fi

  # Extract base DN
  base_dn="$(extract_basedn "$ROOTDSE_FILE")"
  printf "%s\n" "${base_dn:-}" >"$BASEDN_FILE"

  # Derive domain name from base DN (e.g. DC=htb,DC=local -> htb.local)
  if [ -n "$base_dn" ]; then
    domain_name="$(echo "$base_dn" | sed 's/DC=//g;s/,/./g')"
  fi

  # DC hostname from RootDSE if present
  if [ -s "$ROOTDSE_FILE" ]; then
    dc_host="$(grep -m1 '^dnsHostName:' "$ROOTDSE_FILE" 2>/dev/null | sed 's/^dnsHostName:[[:space:]]*//')"
  fi

  if [ -n "$base_dn" ]; then
    echo -e "${yellow}    [*]${end} ${purple}Base DN detected:${end} ${blue}${base_dn}${end}"
  else
    echo -e "${yellow}    [!] No base DN derived from RootDSE; skipping deep LDAP searches on${end} ${blue}${TARGET}:${PORT}${end}"
  fi

  # If no base_dn, we still write a minimal summary and move on
  if [ -z "$base_dn" ]; then
    {
      echo "BASE DN:               <none>"
      echo "DOMAIN:                ${domain_name:-<unknown>}"
      echo "DC Host:               ${dc_host:-<unknown>}"
      echo -n "Anonymous Bind:        "
      [ "$anon_ok" -eq 1 ] && echo "YES" || echo "NO"
      echo
      echo "Users:                 0"
      echo "Groups:                0"
      echo "Computers:             0"
      echo "SPN Accounts:          0"
      echo
      echo "----------------------------"
      echo "[ Human Users ]"
      echo "  (no base DN; no user enumeration)"
      echo
      echo "[ Service Accounts ]"
      echo "  (no base DN; no service enumeration)"
      echo
      echo "[ SPN Accounts ]"
      echo "  (no base DN; no SPN enumeration)"
      echo
      echo "[ High-Privilege Groups ]"
      echo "  (no base DN; no group enumeration)"
      echo
      echo "[ Interesting Users ]"
      echo "  (no base DN; no heuristics)"
      echo
      echo "[ Additional Accounts (objectClass=* only) ]"
      echo "  (no base DN; no objectClass=* enumeration)"
      echo
      echo "[ Suspicious Hidden Accounts ]"
      echo "  (no base DN; no objectClass=* enumeration)"
      echo
      echo "[ Service Smells ]"
      echo "  Exchange:            unknown"
      echo
    } >"$SUMMARY_FILE"

    echo -e "${yellow}    [*]${end} ${purple}LDAP enumeration finished for${end} ${blue}${TARGET}:${PORT}${end} ${purple}(no base DN)${end}"
    continue
  fi

  # --- Domain object info (base DN) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s base \
    -LLL \
    -o nettimeout=8 \
    -l 20 \
    "(objectClass=*)" \
    name distinguishedName objectClass \
    >"$DOMAIN_FILE" 2>/dev/null || true

  # --- Users (non-computer) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(&(objectCategory=person)(objectClass=user))" \
    dn sAMAccountName userPrincipalName displayName description \
    memberOf whenCreated whenChanged adminCount userAccountControl \
    >"$USERS_FILE" 2>/dev/null || true

  if [ -s "$USERS_FILE" ]; then
    users_count="$(grep -c '^dn: ' "$USERS_FILE" 2>/dev/null || true)"
    [ -z "$users_count" ] && users_count=0
  fi

  # --- Groups ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(objectClass=group)" \
    dn sAMAccountName name description member \
    >"$GROUPS_FILE" 2>/dev/null || true

  if [ -s "$GROUPS_FILE" ]; then
    groups_count="$(grep -c '^dn: ' "$GROUPS_FILE" 2>/dev/null || true)"
    [ -z "$groups_count" ] && groups_count=0
  fi

  # --- Computers ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(objectCategory=computer)" \
    dn sAMAccountName dNSHostName operatingSystem operatingSystemVersion \
    servicePrincipalName \
    >"$COMPUTERS_FILE" 2>/dev/null || true

  if [ -s "$COMPUTERS_FILE" ]; then
    computers_count="$(grep -c '^dn: ' "$COMPUTERS_FILE" 2>/dev/null || true)"
    [ -z "$computers_count" ] && computers_count=0
  fi

  # --- SPN-bearing accounts (for later roasting) ---
  ldapsearch -x \
    -H "$url" \
    -b "$base_dn" \
    -s sub \
    -LLL \
    -o nettimeout=10 \
    -l 60 \
    -z 2000 \
    "(servicePrincipalName=*)" \
    dn sAMAccountName userPrincipalName servicePrincipalName \
    >"$SPN_FILE" 2>/dev/null || true

  if [ -s "$SPN_FILE" ]; then
    spn_count="$(grep -c '^dn: ' "$SPN_FILE" 2>/dev/null || true)"
    [ -z "$spn_count" ] && spn_count=0
  fi

"$ROOTDIR/modules/ldap/ldap-accounts" "$OUTDIR" "$TARGET" "$PORT"
# Pull back counters from ldap-accounts
if [ -f "$LDAPDIR/ldap-accounts-status.txt" ]; then
    . "$LDAPDIR/ldap-accounts-status.txt"
    human_count="$HUMAN_COUNT"
    service_count="$SERVICE_COUNT"
    asrep_count="$ASREP_COUNT"
    extra_accounts_count="$EXTRA_COUNT"
fi

  # --- High-privilege groups + Exchange smells via helper ---
  exchange_smell="NO"

  if [ -x "$ROOTDIR/modules/ldap/ldap-groups" ]; then
    "$ROOTDIR/modules/ldap/ldap-groups" "$OUTDIR" "$TARGET" "$PORT"

    if [ -f "$LDAPDIR/ldap-groups-status.txt" ]; then
      . "$LDAPDIR/ldap-groups-status.txt"
      exchange_smell="${EXCHANGE_SMELL:-NO}"
    fi
  fi

  # --- Normalize counters to digits only for extra safety ---
  users_count="${users_count//[^0-9]/}"
  groups_count="${groups_count//[^0-9]/}"
  computers_count="${computers_count//[^0-9]/}"
  spn_count="${spn_count//[^0-9]/}"
  human_count="${human_count//[^0-9]/}"
  service_count="${service_count//[^0-9]/}"
  asrep_count="${asrep_count//[^0-9]/}"
  interesting_count="${interesting_count//[^0-9]/}"
  extra_accounts_count="${extra_accounts_count//[^0-9]/}"

  [ -z "$users_count" ] && users_count=0
  [ -z "$groups_count" ] && groups_count=0
  [ -z "$computers_count" ] && computers_count=0
  [ -z "$spn_count" ] && spn_count=0
  [ -z "$human_count" ] && human_count=0
  [ -z "$service_count" ] && service_count=0
  [ -z "$asrep_count" ] && asrep_count=0
  [ -z "$interesting_count" ] && interesting_count=0
  [ -z "$extra_accounts_count" ] && extra_accounts_count=0

  # --- Console highlight for AS-REP roastables ---
  if [ "$asrep_count" -gt 0 ] && [ -s "$CLASS_FILE" ]; then
    echo -e "${green}    [*] AS-REP roastable accounts detected on${end} ${blue}${TARGET}:${PORT}${end}"
    awk -F'|' '$4=="ASREP_ROASTABLE"{ printf "        - %s (%s)\n", $2, $3 }' "$CLASS_FILE"
  fi

  # --- Console highlight for hidden svc-* accounts ---
  if [ -s "$HIDDEN_FILE" ]; then
    echo -e "${yellow}    [*] Suspicious hidden svc-* accounts (only in objectClass=* dump) on${end} ${blue}${TARGET}:${PORT}${end}"
    sort -u "$HIDDEN_FILE" | while IFS= read -r hs; do
      [ -z "$hs" ] && continue
      echo -e "        - ${red}${hs}${end}"
    done
  fi

  # --- Build human-friendly summary.txt ---

  {
    echo "BASE DN:               ${base_dn:-<none>}"
    echo "DOMAIN:                ${domain_name:-<unknown>}"
    echo "DC Host:               ${dc_host:-<unknown>}"
    echo -n "Anonymous Bind:        "
    [ "$anon_ok" -eq 1 ] && echo "YES" || echo "NO"
    echo

    if [ -s "$CLASS_FILE" ] && [ "$users_count" -gt 0 ]; then
      echo "Users:                 ${users_count} (human: ${human_count}, service: ${service_count})"
    else
      echo "Users:                 ${users_count}"
    fi
    echo "Groups:                ${groups_count}"
    echo "Computers:             ${computers_count}"
    echo "SPN Accounts:          ${spn_count}"
    echo "Extra accounts (objectClass=* only): ${extra_accounts_count}"
    echo
    echo "----------------------------"
    echo "[ Human Users ]"
  } >"$SUMMARY_FILE"

  if [ -s "$CLASS_FILE" ] && [ "$human_count" -gt 0 ]; then
    awk -F'|' '$1=="HUMAN"{ printf "  %-22s %s\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Service Accounts ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$CLASS_FILE" ] && [ "$service_count" -gt 0 ]; then
    awk -F'|' '$1=="SERVICE"{ printf "  %-22s %s\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ SPN Accounts ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$SPN_FILE" ] && [ "$spn_count" -gt 0 ]; then
    awk '
      BEGIN { RS=""; FS="\n" }
      {
        sam=""; spn_first=""
        for (i=1; i<=NF; i++) {
          line=$i
          if (line ~ /^sAMAccountName:[[:space:]]*/) {
            sam=line; sub(/^sAMAccountName:[[:space:]]*/, "", sam)
          } else if (line ~ /^servicePrincipalName:[[:space:]]*/ && spn_first=="") {
            spn_first=line; sub(/^servicePrincipalName:[[:space:]]*/, "", spn_first)
          }
        }
        if (sam != "") {
          if (spn_first == "") spn_first="-"
          printf "  %-22s %s\n", sam, spn_first
        }
      }
    ' "$SPN_FILE" >>"$SUMMARY_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ High-Privilege Groups ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$PRIVGROUP_FILE" ]; then
    while IFS='|' read -r grp gname members; do
      [ -z "$grp" ] && continue
      printf "  %-22s members: %s\n" "$grp" "${members:-0}" >>"$SUMMARY_FILE"
    done <"$PRIVGROUP_FILE"
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Interesting Users ]"
  } >>"$SUMMARY_FILE"

  if [ -s "$INTERESTING_FILE" ] && [ "$interesting_count" -gt 0 ]; then
    echo "  adminCount / admin-group heuristics:" >>"$SUMMARY_FILE"
    echo "    ${interesting_count} entries — see: $INTERESTING_FILE" >>"$SUMMARY_FILE"
  elif [ "$asrep_count" -gt 0 ]; then
    :
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi

  if [ -s "$CLASS_FILE" ] && [ "$asrep_count" -gt 0 ]; then
    echo >>"$SUMMARY_FILE"
    echo "  AS-REP roastable candidates:" >>"$SUMMARY_FILE"
    awk -F'|' '$4=="ASREP_ROASTABLE"{ printf "    %-20s (%s)\n", $2, $3 }' "$CLASS_FILE" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Additional Accounts (objectClass=* only) ]"
  } >>"$SUMMARY_FILE"
  printed_extra=0
  if [ -s "$EXTRA_ACCOUNTS_FILE" ] && [ -s "$CLASS_FILE" ]; then
    while IFS='|' read -r extra_sam extra_ocs; do
      [ -z "$extra_sam" ] && continue
      typ="$(grep -m1 "|${extra_sam}|" "$CLASS_FILE" 2>/dev/null | cut -d'|' -f1)"
      # Only show extras we actually classified (HUMAN/SERVICE/SYSTEM).
      [ -z "$typ" ] && continue
      printf "  %-22s %s\n" "$extra_sam" "$typ" >>"$SUMMARY_FILE"
      printed_extra=1
    done <"$EXTRA_ACCOUNTS_FILE"
  fi
  if [ "$printed_extra" -eq 0 ]; then
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Suspicious Hidden Accounts ]"
  } >>"$SUMMARY_FILE"
  if [ -s "$HIDDEN_FILE" ] && [ -s "$CLASS_FILE" ]; then
    sort -u "$HIDDEN_FILE" | while IFS= read -r hs; do
      [ -z "$hs" ] && continue
      line="$(grep -m1 "|${hs}|" "$CLASS_FILE" 2>/dev/null || true)"
      [ -z "$line" ] && continue
      typ="$(printf '%s\n' "$line" | cut -d'|' -f1)"
      state="$(printf '%s\n' "$line" | cut -d'|' -f3)"
      asrep_flag="$(printf '%s\n' "$line" | cut -d'|' -f4)"
      [ -z "$typ" ] && typ="UNKNOWN"
      [ -z "$state" ] && state="unknown"
      if [ "$asrep_flag" = "ASREP_ROASTABLE" ]; then
        printf "  %-22s %s (%s, %s)\n" "$hs" "$typ" "$state" "AS-REP roastable" >>"$SUMMARY_FILE"
      else
        printf "  %-22s %s (%s)\n" "$hs" "$typ" "$state" >>"$SUMMARY_FILE"
      fi
    done
  else
    echo "  (none detected)" >>"$SUMMARY_FILE"
  fi
  echo >>"$SUMMARY_FILE"

  {
    echo "[ Service Smells ]"
    echo "  Exchange:            ${exchange_smell}"
    echo
  } >>"$SUMMARY_FILE"

  # --- fire ldap-treasure for this port ---
  if [ -x "$ROOTDIR/modules/ldap/ldap-treasure" ]; then
    "$ROOTDIR/modules/ldap/ldap-treasure" "$OUTDIR" "$PORT" 2>/dev/null || \
      echo -e "${yellow}    [!]${end} ${purple}ldap-treasure encountered an error on${end} ${blue}${TARGET}:${PORT}${end}"
  else
    echo -e "${yellow}    [!]${end} ${purple}ldap-treasure not found or not executable; skipping loot extraction for${end} ${blue}${TARGET}:${PORT}${end}"
  fi

  echo -e "${yellow}    [*]${end} ${purple}LDAP enumeration finished for${end} ${blue}${TARGET}:${PORT}${end} ${purple}(users: $users_count, groups: $groups_count, computers: $computers_count, SPNs: $spn_count)${end}"
done

echo -e "${yellow}[+]${end} ${purple}LDAP module finished for target${end} ${blue}${TARGET}${end}"
exit 0
