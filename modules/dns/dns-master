#!/usr/bin/env bash
# dns-master — DNS enumeration using dig (+ optional dnsenum, SRV, CHAOS, light sub-brute)
# Usage:
#   dns-master OUTDIR TARGET [TARGETED_XML] [PORTS]
#
# Behavior:
#   - If TARGET is an IP: do reverse lookup (PTR); use PTR hostname as domain guess if present.
#   - If TARGET looks like a hostname: use it directly as domain guess.
#   - For each DNS-ish port (53, 853) we:
#       * Query core records via system resolver and directly against TARGET:PORT.
#       * Extract NS and attempt AXFR (zone transfer) per NS.
#       * Query CHAOS TXT (version.bind, hostname.bind, id.server) against TARGET:PORT.
#       * Query key SRV records (AD/LDAP/Kerberos/etc.) if a domain guess exists.
#       * Perform a tiny subdomain brute against TARGET:PORT with a built-in short list.
#       * Collect discovered hostnames into hosts_from_dns.txt.
#       * Write artifacts under OUTDIR/dns/<PORT>/:
#           summary.txt         — everything in one place
#           reverse.txt         — PTR lookups
#           records.txt         — A/AAAA/MX/TXT/NS/SOA answers
#           ns.txt              — NS list
#           zone-transfer.txt   — AXFR attempts/results
#           chaos.txt           — CHAOS TXT results (if any)
#           srv.txt             — SRV answers (AD-ish, etc.)
#           subdomains.txt      — tiny sub-bruteforce results
#           hosts_from_dns.txt  — hostnames extracted from SRV/subdomains
#           dnsenum.txt         — only on port 53 when dnsenum runs
#   - If dnsenum is installed and domain guess looks like a domain, run it once on port 53.

ROOTDIR="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")/../.." >/dev/null 2>&1 && pwd)"
. "$ROOTDIR/lib/colors"

SCRIPT_NAME="${0##*/}"

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME OUTDIR TARGET [TARGETED_XML] [PORTS]

Positional:
  OUTDIR       Target output directory (per-host root used by Lantern)
  TARGET       IP or hostname (as used by nmap core)
  TARGETED_XML Optional nmap -sCV XML (currently unused)
  PORTS        Optional comma-separated DNS ports (e.g. "53" or "53,853")
               If omitted, defaults to 53.
EOF
  exit 1
}

OUTDIR="${1:-}"
TARGET="${2:-}"
TARGETED_XML="${3:-}"
PORTS_ARG="${4:-}"

if [ -z "$OUTDIR" ] || [ -z "$TARGET" ]; then
  usage
fi

if ! command -v dig >/dev/null 2>&1; then
  echo -e "${yellow}[!]${end} ${purple}dig not found; skipping DNS module.${end}"
  exit 0
fi

mkdir -p "$OUTDIR/dns"

echo -e "${yellow}[*]${end} ${purple}DNS module started for target${end} ${blue}${TARGET}${end}"

# --- Determine if TARGET is IPv4 and derive a "domain guess" ---

is_ipv4=false
if [[ "$TARGET" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
  is_ipv4=true
fi

domain_guess=""

# Reverse lookup via system resolver to derive domain_guess when TARGET is IP
if [ "$is_ipv4" = true ]; then
  ptr_host="$(dig -x "$TARGET" +short 2>/dev/null | tr -d '\r' | head -n1)"
  if [ -n "$ptr_host" ]; then
    domain_guess="${ptr_host%.}"   # strip trailing dot if present
  fi
else
  domain_guess="$TARGET"
fi

# --- Ports: limit to DNS-ish ports (53, 853) for now ---

ports=()

if [ -n "$PORTS_ARG" ]; then
  IFS=',' read -r -a raw_ports <<< "$PORTS_ARG"
  for p in "${raw_ports[@]}"; do
    p_clean="${p//[^0-9]/}"
    [ -z "$p_clean" ] && continue
    case "$p_clean" in
      53|853)
        ports+=("$p_clean")
        ;;
      *)
        # Ignore other ports here; dispatch should only feed DNS-ish ports.
        ;;
    esac
  done
fi

# Default to 53 if nothing usable was provided
if [ "${#ports[@]}" -eq 0 ]; then
  ports=(53)
fi

# Decide whether we will run dnsenum (once) and on which port dir
dnsenum_port=""
if command -v dnsenum >/dev/null 2>&1 && [ -n "$domain_guess" ] && [[ "$domain_guess" == *.* ]]; then
  # Only run dnsenum when 53 is present; that's the sane place to attach it.
  for p in "${ports[@]}"; do
    if [ "$p" = "53" ]; then
      dnsenum_port="53"
      break
    fi
  done
fi

# Tiny built-in subdomain list (deliberately small)
sub_brute_words=(
  www
  mail
  webmail
  owa
  vpn
  dev
  test
  api
  portal
  intranet
  gw
  rdp
  dc
  dc01
  dc02
  files
  fs
  sql
  stage
  staging
)

for PORT in "${ports[@]}"; do
  DNSDIR="$OUTDIR/dns/$PORT"
  mkdir -p "$DNSDIR"

  SUMMARY_FILE="$DNSDIR/summary.txt"
  REVERSE_FILE="$DNSDIR/reverse.txt"
  RECORDS_FILE="$DNSDIR/records.txt"
  NS_FILE="$DNSDIR/ns.txt"
  AXFR_FILE="$DNSDIR/zone-transfer.txt"
  CHAOS_FILE="$DNSDIR/chaos.txt"
  SRV_FILE="$DNSDIR/srv.txt"
  SUBDOM_FILE="$DNSDIR/subdomains.txt"
  HOSTS_DNS_FILE="$DNSDIR/hosts_from_dns.txt"
  DNSENUM_FILE="$DNSDIR/dnsenum.txt"

  : >"$SUMMARY_FILE"
  : >"$REVERSE_FILE"
  : >"$RECORDS_FILE"
  : >"$NS_FILE"
  : >"$AXFR_FILE"
  : >"$CHAOS_FILE"
  : >"$SRV_FILE"
  : >"$SUBDOM_FILE"
  : >"$HOSTS_DNS_FILE"
  : >"$DNSENUM_FILE"

  case "$PORT" in
    53)
      port_label="DNS (standard port 53)"
      ;;
    853)
      port_label="DNS over TLS candidate (port 853)"
      ;;
    *)
      port_label="DNS-like service on non-standard port $PORT"
      ;;
  esac

  {
    echo "==== DNS Module Start ===="
    echo "Target:       $TARGET"
    echo "Port:         $PORT"
    echo "Port label:   $port_label"
    echo "Domain guess: ${domain_guess:-<none>}"
    echo
  } >>"$SUMMARY_FILE"

  # --- Reverse lookups (PTR) ---

  {
    echo "==== Reverse lookup (PTR) via system resolver ===="
    if [ "$is_ipv4" = true ]; then
      dig -x "$TARGET" +short 2>/dev/null || echo "<no PTR via system resolver>"
    else
      echo "<target not an IPv4 address>"
    fi
    echo
    echo "==== Reverse lookup (PTR) via $TARGET:$PORT ===="
    if [ "$is_ipv4" = true ]; then
      dig -x "$TARGET" @"$TARGET" -p "$PORT" +short 2>/dev/null || echo "<no PTR via $TARGET:$PORT>"
    else
      echo "<target not an IPv4 address>"
    fi
    echo
  } | tee "$REVERSE_FILE" >>"$SUMMARY_FILE"

  ns_count=0

  # --- Forward lookups & core records only if we have a domain guess ---
  if [ -n "$domain_guess" ]; then
    {
      echo "==== Forward lookups for: $domain_guess ===="
      echo "-- A records (system resolver) --"
      dig "$domain_guess" A +noall +answer 2>/dev/null || true
      echo
      echo "-- A records (@$TARGET#$PORT) --"
      dig "$domain_guess" A @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
      echo "-- AAAA records (system resolver) --"
      dig "$domain_guess" AAAA +noall +answer 2>/dev/null || true
      echo
      echo "-- AAAA records (@$TARGET#$PORT) --"
      dig "$domain_guess" AAAA @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
      echo "-- MX records (system resolver) --"
      dig "$domain_guess" MX +noall +answer 2>/dev/null || true
      echo
      echo "-- MX records (@$TARGET#$PORT) --"
      dig "$domain_guess" MX @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
      echo "-- TXT records (system resolver) --"
      dig "$domain_guess" TXT +noall +answer 2>/dev/null || true
      echo
      echo "-- TXT records (@$TARGET#$PORT) --"
      dig "$domain_guess" TXT @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
      echo "-- NS records (system resolver) --"
      dig "$domain_guess" NS +noall +answer 2>/dev/null || true
      echo
      echo "-- NS records (@$TARGET#$PORT) --"
      dig "$domain_guess" NS @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
      echo "-- SOA record (system resolver) --"
      dig "$domain_guess" SOA +noall +answer 2>/dev/null || true
      echo
      echo "-- SOA record (@$TARGET#$PORT) --"
      dig "$domain_guess" SOA @"$TARGET" -p "$PORT" +noall +answer 2>/dev/null || true
      echo
    } | tee "$RECORDS_FILE" >>"$SUMMARY_FILE"

    # Extract NS servers (system + direct) -> ns.txt
    {
      dig "$domain_guess" NS +short 2>/dev/null || true
      dig "$domain_guess" NS @"$TARGET" -p "$PORT" +short 2>/dev/null || true
    } | sed -e 's/\.$//' | sort -u | sed '/^$/d' >"$NS_FILE" || true

    if [ -s "$NS_FILE" ]; then
      ns_count="$(wc -l < "$NS_FILE" 2>/dev/null || echo 0)"
    else
      ns_count=0
    fi

    # --- Mail-related TXT (SPF/DMARC) quick view ---
    {
      echo "==== Mail-related TXT (SPF/DMARC) for $domain_guess (system resolver) ===="
      dig "$domain_guess" TXT +short 2>/dev/null \
        | grep -Ei 'v=spf1|v=DMARC1' || echo "<no explicit SPF/DMARC TXT found>"
      echo
    } >>"$SUMMARY_FILE"

    # --- AXFR attempts per NS ---
    if [ "$ns_count" -gt 0 ]; then
      {
        echo "==== AXFR attempts (zone transfer) for $domain_guess ===="
      } >>"$SUMMARY_FILE"

      while IFS= read -r ns; do
        [ -z "$ns" ] && continue
        {
          echo "---- AXFR attempt: domain=$domain_guess ns=$ns ----"
          dig "$domain_guess" AXFR @"$ns" +time=10 +tries=1 2>/dev/null || echo "<AXFR failed or refused>"
          echo
        } | tee -a "$AXFR_FILE" >>"$SUMMARY_FILE"
      done <"$NS_FILE"
    else
      {
        echo "==== AXFR attempts ===="
        echo "No NS records discovered; skipping AXFR."
        echo
      } >>"$SUMMARY_FILE"
    fi

    # --- CHAOS TXT (version.bind / hostname.bind / id.server) ---
    chaos_buf=""
    for chaos_name in version.bind hostname.bind id.server; do
      out="$(dig "$chaos_name" TXT CH @"$TARGET" -p "$PORT" +short 2>/dev/null | tr -d '\r')"
      if [ -n "$out" ]; then
        chaos_buf+=$'\n'"$chaos_name (CHAOS TXT):"
        chaos_buf+=$'\n'"$out"$'\n'
      fi
    done

    if [ -n "$chaos_buf" ]; then
      {
        echo "==== CHAOS TXT (version.bind / hostname.bind / id.server) ===="
        printf '%s\n' "$chaos_buf"
        echo
      } | tee "$CHAOS_FILE" >>"$SUMMARY_FILE"
    else
      {
        echo "==== CHAOS TXT ===="
        echo "No CHAOS TXT responses from $TARGET:$PORT."
        echo
      } | tee "$CHAOS_FILE" >>"$SUMMARY_FILE"
    fi

    # --- AD / SRV records (if domain_guess looks domain-ish) ---
    if [[ "$domain_guess" == *.* ]]; then
      {
        echo "==== AD / SRV records for $domain_guess (@$TARGET#$PORT) ===="
      } | tee -a "$SRV_FILE" >>"$SUMMARY_FILE"

      srv_names=(
        "_ldap._tcp.${domain_guess}"
        "_ldap._tcp.dc._msdcs.${domain_guess}"
        "_kerberos._tcp.${domain_guess}"
        "_kerberos._udp.${domain_guess}"
        "_kpasswd._tcp.${domain_guess}"
        "_kpasswd._udp.${domain_guess}"
        "_gc._tcp.${domain_guess}"
      )

      for s in "${srv_names[@]}"; do
        out="$(dig "$s" SRV @"$TARGET" -p "$PORT" +short 2>/dev/null | tr -d '\r')"
        {
          echo "-- $s SRV --"
          if [ -n "$out" ]; then
            printf '%s\n' "$out"
          else
            echo "<no answer>"
          fi
          echo
        } | tee -a "$SRV_FILE" >>"$SUMMARY_FILE"

        # Extract targets from SRV answers into hosts_from_dns.txt
        if [ -n "$out" ]; then
          while IFS= read -r line; do
            # Typical SRV: priority weight port target
            host_field="$(printf '%s\n' "$line" | awk '{print $4}')"
            host_field="${host_field%.}"
            [ -n "$host_field" ] && printf '%s\n' "$host_field" >>"$HOSTS_DNS_FILE"
          done <<< "$out"
        fi
      done
    fi

    # --- Tiny subdomain bruteforce (@TARGET#$PORT) ---
    if [[ "$domain_guess" == *.* ]]; then
      {
        echo "==== Tiny subdomain brute (@$TARGET#$PORT) for *.$domain_guess ===="
      } | tee -a "$SUBDOM_FILE" >>"$SUMMARY_FILE"

      for sub in "${sub_brute_words[@]}"; do
        fqdn="${sub}.${domain_guess}"
        a_out="$(dig "$fqdn" A @"$TARGET" -p "$PORT" +short 2>/dev/null | tr -d '\r')"
        if [ -n "$a_out" ]; then
          line="${fqdn} ${a_out}"
          printf '%s\n' "$line" | tee -a "$SUBDOM_FILE" >>"$SUMMARY_FILE"
          printf '%s\n' "$fqdn" >>"$HOSTS_DNS_FILE"
        fi
      done

      echo >>"$SUMMARY_FILE"
    fi

  else
    {
      echo "==== Forward lookups ===="
      echo "No domain guess derived; only reverse lookups performed."
      echo
    } >>"$SUMMARY_FILE"
  fi

  # --- dnsenum (only once, on port 53) ---
  if [ -n "$dnsenum_port" ] && [ "$PORT" = "$dnsenum_port" ]; then
    echo -e "${yellow}[*]${end} ${purple}Running dnsenum against${end} ${blue}${domain_guess}${end} ${purple}(attached to port 53).${end}"
    {
      echo "==== dnsenum output for $domain_guess ===="
      dnsenum "$domain_guess" 2>&1 || echo "<dnsenum failed>"
      echo
    } | tee "$DNSENUM_FILE" >>"$SUMMARY_FILE"
  fi

  # --- Deduplicate hosts_from_dns.txt if anything is there ---
  if [ -s "$HOSTS_DNS_FILE" ]; then
    sort -u "$HOSTS_DNS_FILE" -o "$HOSTS_DNS_FILE" 2>/dev/null || true
  fi

  # --- Per-port summary footer ---
  {
    echo "==== DNS Port Summary ===="
    echo "Target:        $TARGET"
    echo "Port:          $PORT"
    echo "Port label:    $port_label"
    echo "Domain guess:  ${domain_guess:-<none>}"
    echo "NS count:      $ns_count"
    echo "Reverse file:  $REVERSE_FILE"
    echo "Records file:  $RECORDS_FILE"
    echo "NS list file:  $NS_FILE"
    echo "AXFR file:     $AXFR_FILE"
    echo "CHAOS file:    $CHAOS_FILE"
    echo "SRV file:      $SRV_FILE"
    echo "Subdomains:    $SUBDOM_FILE"
    echo "Hosts from DNS:$HOSTS_DNS_FILE"
    if [ -n "$dnsenum_port" ] && [ "$PORT" = "$dnsenum_port" ]; then
      echo "dnsenum file:  $DNSENUM_FILE"
    fi
    echo
  } >>"$SUMMARY_FILE"

  echo -e "${yellow}[*]${end} ${purple}DNS module completed for port${end} ${blue}${PORT}${end}"
done

echo -e "${yellow}[+]${end} ${purple}DNS module finished for target${end} ${blue}${TARGET}${end}"
exit 0
