#!/usr/bin/env bash
# dns-master — trimmed DNS helper for Lantern (pentest-focused)
#
# Usage:
#   dns-master OUTDIR TARGET [TARGETED_XML] [PORTS]
#
# Behavior:
#   - Always:
#       * Do a PTR lookup for TARGET via system resolver and save it.
#   - If PTR yields a usable FQDN (has letters + a dot):
#       * domain_guess = everything after the first label.
#       * Query key AD SRV records via system resolver:
#           _ldap._tcp.dc._msdcs.domain
#           _kerberos._tcp.domain
#           _kerberos._udp.domain
#           _kpasswd._tcp.domain
#           _kpasswd._udp.domain
#       * Extract hostnames from SRV answers into hosts_from_dns.txt.
#   - CHAOS:
#       * Always try version.bind / hostname.bind / id.server against TARGET:DNS_PORT
#         (where DNS_PORT is 53 by default or the first DNS-ish port from PORTS).
#       * Dig calls have tight timeouts so they can’t hang.
#   - No dnsenum, no brute-forcing, no A/MX/TXT/NS/SOA spam.

ROOTDIR="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")/../.." >/dev/null 2>&1 && pwd)"
. "$ROOTDIR/lib/colors"

SCRIPT_NAME="${0##*/}"

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME OUTDIR TARGET [TARGETED_XML] [PORTS]

Positional:
  OUTDIR       Target output directory (per-host root used by Lantern)
  TARGET       IP or hostname (as used by nmap core)
  TARGETED_XML Optional nmap -sCV XML (unused for now)
  PORTS        Optional comma-separated ports; first DNS-ish (53/853)
               is used as the CHAOS target port. Defaults to 53.
EOF
  exit 1
}

OUTDIR="${1:-}"
TARGET="${2:-}"
TARGETED_XML="${3:-}"
PORTS_ARG="${4:-}"

if [ -z "$OUTDIR" ] || [ -z "$TARGET" ]; then
  usage
fi

if ! command -v dig >/dev/null 2>&1; then
  echo -e "${yellow}[!]${end} ${purple}dig not found; skipping DNS module.${end}"
  exit 0
fi

# Tunables
DIG_TIME="${DIG_TIME:-5}"       # seconds per dig query
DIG_TRIES="${DIG_TRIES:-1}"     # tries per dig query

# Pick a DNS port to talk CHAOS to (53 by default)
DNS_PORT=53
if [ -n "$PORTS_ARG" ]; then
  IFS=',' read -r -a raw_ports <<< "$PORTS_ARG"
  for p in "${raw_ports[@]}"; do
    p_clean="${p//[^0-9]/}"
    [ -z "$p_clean" ] && continue
    case "$p_clean" in
      53|853)
        DNS_PORT="$p_clean"
        break
        ;;
    esac
  done
fi

DNSDIR="$OUTDIR/dns/$DNS_PORT"
mkdir -p "$DNSDIR"

SUMMARY_FILE="$DNSDIR/summary.txt"
REVERSE_FILE="$DNSDIR/reverse.txt"
SRV_FILE="$DNSDIR/srv.txt"
CHAOS_FILE="$DNSDIR/chaos.txt"
HOSTS_DNS_FILE="$DNSDIR/hosts_from_dns.txt"

: >"$SUMMARY_FILE"
: >"$REVERSE_FILE"
: >"$SRV_FILE"
: >"$CHAOS_FILE"
: >"$HOSTS_DNS_FILE"

echo -e "${yellow}[*]${end} ${purple}DNS module started for target${end} ${blue}${TARGET}${end}"

# --- PTR lookup (system resolver only) ---

PTR_FQDN="$(dig -x "$TARGET" +short +time="$DIG_TIME" +tries="$DIG_TRIES" 2>/dev/null | tr -d '\r' | head -n1)"

{
  echo "==== DNS Module Start ===="
  echo "Target:       $TARGET"
  echo "DNS port:     $DNS_PORT"
  echo
  echo "==== Reverse lookup (PTR) via system resolver ===="
  if [ -n "$PTR_FQDN" ]; then
    echo "$PTR_FQDN"
  else
    echo "<no PTR via system resolver>"
  fi
  echo
} | tee "$REVERSE_FILE" >>"$SUMMARY_FILE"

# --- Derive domain_guess from PTR FQDN ---

domain_guess=""

if [ -n "$PTR_FQDN" ]; then
  # strip trailing dot
  fqdn="${PTR_FQDN%.}"

  # Require at least one letter and at least one dot
  if [[ "$fqdn" =~ [A-Za-z] ]] && [[ "$fqdn" == *.* ]]; then
    # Drop first label: host.domain.tld -> domain.tld
    domain_guess="${fqdn#*.}"
  fi
fi

if [ -z "$domain_guess" ]; then
  {
    echo "==== Domain guess ===="
    echo "PTR did not yield a usable FQDN with letters; skipping SRV/domain-based DNS enum."
    echo
  } >>"$SUMMARY_FILE"
else
  {
    echo "==== Domain guess ===="
    echo "PTR FQDN:     ${PTR_FQDN:-<none>}"
    echo "Domain guess: $domain_guess"
    echo
  } >>"$SUMMARY_FILE"

  # --- AD / SRV records via system resolver only ---

  {
    echo "==== AD / SRV records for $domain_guess (system resolver) ===="
  } | tee -a "$SRV_FILE" >>"$SUMMARY_FILE"

  srv_names=(
    "_ldap._tcp.dc._msdcs.${domain_guess}"
    "_kerberos._tcp.${domain_guess}"
    "_kerberos._udp.${domain_guess}"
    "_kpasswd._tcp.${domain_guess}"
    "_kpasswd._udp.${domain_guess}"
  )

  for s in "${srv_names[@]}"; do
    out="$(dig "$s" SRV +short +time="$DIG_TIME" +tries="$DIG_TRIES" 2>/dev/null | tr -d '\r')"
    {
      echo "-- $s SRV (system) --"
      if [ -n "$out" ]; then
        printf '%s\n' "$out"
      else
        echo "<no answer>"
      fi
      echo
    } | tee -a "$SRV_FILE" >>"$SUMMARY_FILE"

    # Extract targets from SRV answers into hosts_from_dns.txt
    if [ -n "$out" ]; then
      while IFS= read -r line; do
        host_field="$(printf '%s\n' "$line" | awk '{print $4}')"
        host_field="${host_field%.}"
        # only keep things that look like hostnames (has a dot and at least one letter)
        if [[ "$host_field" == *.* ]] && [[ "$host_field" =~ [A-Za-z] ]]; then
          printf '%s\n' "$host_field" >>"$HOSTS_DNS_FILE"
        fi
      done <<< "$out"
    fi
  done

  # Deduplicate hosts_from_dns.txt if anything is there
  if [ -s "$HOSTS_DNS_FILE" ]; then
    sort -u "$HOSTS_DNS_FILE" -o "$HOSTS_DNS_FILE" 2>/dev/null || true
  fi
fi

# --- CHAOS TXT (version.bind / hostname.bind / id.server) against TARGET:DNS_PORT ---

chaos_buf=""
for chaos_name in version.bind hostname.bind id.server; do
  out="$(dig "$chaos_name" TXT CH @"$TARGET" -p "$DNS_PORT" +short +time="$DIG_TIME" +tries="$DIG_TRIES" 2>/dev/null | tr -d '\r')"
  if [ -n "$out" ]; then
    chaos_buf+=$'\n'"$chaos_name (CHAOS TXT):"
    chaos_buf+=$'\n'"$out"$'\n'
  fi
done

{
  echo "==== CHAOS TXT (version.bind / hostname.bind / id.server) ===="
  if [ -n "$chaos_buf" ]; then
    printf '%s\n' "$chaos_buf"
  else
    echo "No CHAOS TXT responses from $TARGET:$DNS_PORT."
  fi
  echo
} | tee "$CHAOS_FILE" >>"$SUMMARY_FILE"

# --- Final summary ---

{
  echo "==== DNS Summary ===="
  echo "Target:        $TARGET"
  echo "DNS port:      $DNS_PORT"
  echo "PTR FQDN:      ${PTR_FQDN:-<none>}"
  echo "Domain guess:  ${domain_guess:-<none>}"
  echo "SRV file:      $SRV_FILE"
  echo "CHAOS file:    $CHAOS_FILE"
  echo "Hosts from DNS:$HOSTS_DNS_FILE"
  echo
} >>"$SUMMARY_FILE"

echo -e "${yellow}[+]${end} ${purple}DNS module finished for target${end} ${blue}${TARGET}${end}"
exit 0
