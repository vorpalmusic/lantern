#!/bin/bash
# author: JackDaw

### GRAB IP 'target' AND ROOT DIRECTORY, THEN CALL PATHFINDER TO SET ALL RELATIVE PATH VARS
target="$1"
rootdir="$(cd -- "$(dirname -- "$(readlink -f -- "${BASH_SOURCE[0]}")")" >/dev/null 2>&1 && pwd)"
. "$rootdir/lib/pathfinder"

## LOAD LIBRARIES
. "$ROOTDIR/lib/colors"

## IF TARGET IP IS MISSING, GIVE ERROR ASKING FOR IT
if [ -z "$1" ]; then
    echo -e "\n${yellow}[!]${end} ${purple}Usage:${end} ${blue}$0 <IP>${end}"
    exit 1
fi

## MAKE OUTPUT FOLDER BASED ON TARGET IP + REPORT SUBFOLDER
mkdir -p "$OUTDIR" "$REPORTDIR"
echo -e "${yellow}[*]${end} ${purple}Using output directory:${end} ${blue}$OUTDIR${end}"

"$MODDIR/banner"        ## cue banner

## BEGIN WORK.
### run fast discovery scan just to find open ports (no live verbose spam)
echo -e "\n${yellow}[*]${end} ${purple}Rapid nmap port discovery on${end} ${blue}$target${end}${purple}...${end}\n"

ALLPORTS="$REPORTDIR/allPorts"
PART1="$REPORTDIR/allPorts.p1"
PART2="$REPORTDIR/allPorts.p2"
PART3="$REPORTDIR/allPorts.p3"

# Clean old artifacts if they exist
rm -f "$ALLPORTS" "$PART1" "$PART2" "$PART3"

# Run three concurrent range scans to speed up discovery.
# Combined, these cover 1–65535 without overlap:
#   1–22000, 22001–44000, 44001–65535
sudo /usr/bin/nmap \
  -p1-22000 --open -sS -n -Pn \
  --min-rate 2500 \
  --max-retries 1 \
  -T3 \
  -oG "$PART1" \
  "$target" >/dev/null 2>&1 &

pid1=$!

sudo /usr/bin/nmap \
  -p22001-44000 --open -sS -n -Pn \
  --min-rate 2500 \
  --max-retries 1 \
  -T3 \
  -oG "$PART2" \
  "$target" >/dev/null 2>&1 &

pid2=$!

sudo /usr/bin/nmap \
  -p44001-65535 --open -sS -n -Pn \
  --min-rate 2500 \
  --max-retries 1 \
  -T3 \
  -oG "$PART3" \
  "$target" >/dev/null 2>&1 &

pid3=$!

# Wait for all three discovery scans to finish
wait "$pid1" "$pid2" "$pid3" 2>/dev/null || true

# Merge into a single greppable file so the rest of the script
# can continue to treat $ALLPORTS exactly as before.
: > "$ALLPORTS"
[ -f "$PART1" ] && cat "$PART1" >> "$ALLPORTS"
[ -f "$PART2" ] && cat "$PART2" >> "$ALLPORTS"
[ -f "$PART3" ] && cat "$PART3" >> "$ALLPORTS"

# Optionally clean up the parts
rm -f "$PART1" "$PART2" "$PART3"

# If greppable file exists, extract ports reliably and print them once
if [ -f "$ALLPORTS" ]; then
  # extract unique port numbers (e.g. 22, 80)
  discovered_ports=$(grep -oP '\d{1,5}/open' "$ALLPORTS" | cut -d'/' -f1 | sort -n -u)

  if [ -n "$discovered_ports" ]; then
    echo -e "${yellow}[*]${end} ${purple}Discovered open ports:${end}"
    while IFS= read -r p; do
      # sanity: ensure p is numeric
      p="${p//[^0-9]/}"
      [ -n "$p" ] && echo "  Discovered open port ${p}/tcp on $target"
    done <<< "$discovered_ports"
  else
    echo -e "${yellow}[!]${end} ${purple}No open ports discovered in greppable output.${end}"
  fi
else
  echo -e "${yellow}[!]${end} ${purple}Nmap greppable output missing: $ALLPORTS${end}"
fi

### grab all those ports from the nmap scan and put them in a list
ports=""
if [ -f "$ALLPORTS" ]; then
  ports=$(grep -oP '\d{1,5}/open' "$ALLPORTS" | cut -d '/' -f1 | xargs | tr ' ' ',')
fi

echo -e "\n${yellow}[*]${end} ${purple}Extracting information...${end}\n"
echo -e "\t${yellow}[*]${end} ${purple}IP Address:${end} ${blue}$target${end}"
echo -e "\t${yellow}[*]${end} ${purple}Open ports:${end} ${blue}${ports:-<none>}${end}\n"

# --- targeted scan (only if we have ports, runs synchronously) ---
TARGETED_XML="$REPORTDIR/targetedXML"

if [ -n "$ports" ]; then
  echo -e "${yellow}[*]${end} ${purple}Targeted version and service scanning with nmap...${end}"
  sudo /usr/bin/nmap -sCV -p"$ports" -n -Pn --max-retries 2 --host-timeout 120s "$target" -A \
       -oX "$TARGETED_XML" >/dev/null 2>&1
else
  echo -e "${yellow}[!]${end} ${purple}No open ports detected; skipping targeted scan.${end}"
fi

# --- service dispatch (SSH / HTTP / HTTP-CMS, etc.) ---
# Pass OUTDIR, target, targeted XML, and port list so dispatcher has context
"$ROOTDIR/scripts/dispatch" "$OUTDIR" "$target" "$TARGETED_XML" "$ports" || true
# --- end dispatcher ---

# ... generate HTML deep dive
# Robust stylesheet resolution: honor env if provided, else use common paths
: "${NMAP_XSL:=/usr/share/nmap/nmap.xsl}"
if [ ! -f "$NMAP_XSL" ]; then
  NMAP_XSL="$(find /usr/local/share /usr/share /opt -type f -name nmap.xsl 2>/dev/null | head -n1 || true)"
fi

REPORT_HTML="$REPORTDIR/index.html"

if [ -s "$TARGETED_XML" ]; then
  if [ -n "$NMAP_XSL" ] && [ -f "$NMAP_XSL" ]; then
    xsltproc -o "$REPORT_HTML" "$NMAP_XSL" "$TARGETED_XML" || echo "[!] xsltproc failed"
    # >>> Append Lantern module summary via reporter <<<
    rep="$ROOTDIR/scripts/reporter"
    if [ -x "$rep" ]; then
      "$rep" "$OUTDIR" || echo "[!] reporter failed"
    else
      echo "[!] reporter not found or not executable; skipping module summary"
    fi
  else
    echo "[!] nmap.xsl stylesheet not found; cannot generate HTML"
  fi
else
  echo "[!] targetedXML missing or empty; skipping HTML generation"
fi

# --- wait briefly for index.html to appear (fast loop, up to ~5 seconds) ---
tries=0
while [ $tries -lt 50 ] && [ ! -s "$REPORT_HTML" ]; do
  sleep 0.1
  tries=$((tries + 1))
done
# --- end wait loop ---

if [ -s "$REPORT_HTML" ]; then
  # 1) Ensure no stale server is hogging 9999 (port conflicts cause silent failures)
  if command -v lsof >/dev/null 2>&1; then
    stale_pids="$(lsof -tiTCP:9999 -sTCP:LISTEN 2>/dev/null || true)"
    if [ -n "$stale_pids" ]; then
      echo "[*] Cleaning up existing server(s) on 9999: $stale_pids"
      kill $stale_pids 2>/dev/null || true
      sleep 0.2
    fi
  else
    # Fallback if lsof is missing
    stale_pids="$(/usr/sbin/fuser -n tcp 9999 2>/dev/null || true)"
    [ -n "$stale_pids" ] && { echo "[*] Cleaning up existing server(s) on 9999: $stale_pids"; kill $stale_pids 2>/dev/null || true; sleep 0.2; }
  fi

  # 2) Start a fresh server rooted at OUTDIR (so /http/... and /report/... both work)
  python3 -m http.server 9999 --bind 127.0.0.1 -d "$OUTDIR" >/dev/null 2>&1 &
  server_pid=$!
  # give it a brief moment to fail fast if it will
  sleep 0.15
  if ! kill -0 "$server_pid" 2>/dev/null; then
    echo "[!] http.server failed to start on 127.0.0.1:9999 (likely EADDRINUSE or bad args)."
    echo "    Try: python3 -m http.server 9999 --bind 127.0.0.1 -d \"$OUTDIR\" (without redirection) to see stderr."
    exit 1
  fi
  disown "$server_pid" 2>/dev/null || true

  # index.html lives under report/
  url="http://127.0.0.1:9999/report/index.html"

  echo -e "${yellow}[*]${end} ${purple}Report:${end} ${blue}$url${end}"

  # 3) Sanity check: confirm the server is serving THIS file (not an old docroot)
  if command -v curl >/dev/null 2>&1; then
    # Compare sizes as a cheap fingerprint
    local_sz=$(wc -c < "$REPORT_HTML" 2>/dev/null || echo 0)
    remote_sz=$(curl -fsSI "$url" | awk 'tolower($1)=="content-length:"{print $2}' | tr -d '\r' )
    if [ -n "$remote_sz" ] && [ "$remote_sz" != "$local_sz" ]; then
      echo "[!] Warning: server on 9999 is not serving the expected index.html (size $remote_sz vs $local_sz)."
      echo "    A stale server or different docroot may still be active."
    elif ! curl -fsS "$url" >/dev/null 2>&1; then
      echo "[!] Warning: server started but index.html not reachable at $url"
    fi
  fi

  ( xdg-open "$url" >/dev/null 2>&1 || /usr/bin/firefox "$url" >/dev/null 2>&1 ) &
else
  echo "[!] index.html not found; not starting web server"
fi

exit 0
