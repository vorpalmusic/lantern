#!/usr/bin/env bash
# add-hosts — append missing "IP hostname" pairs from Nmap XML + HTTP probes to /etc/hosts
# Usage:
#   add-hosts OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]

set -euo pipefail

DRY_RUN=0

# Upsert one host into /etc/hosts (update if host exists, else join same-IP line, else append)
# Case-insensitive for hostnames; ignores trailing dot; preserves alias order/case; no backups.
# Usage: upsert_host_entry <ip> <host> [alias1 alias2 ...]
upsert_host_entry() {
  local ip="$1"; shift
  local host="$1"; shift
  local extras=("$@")

  # Build space-separated extras with original casing; we’ll compare in lowercase
  local alias_str=""
  if ((${#extras[@]})); then alias_str="${extras[*]}"; fi

  # In dry-run mode, just print what we *would* do and bail early.
  if [ "${DRY_RUN:-0}" -eq 1 ]; then
    echo "[dry-run] would ensure ${host} → ${ip} (extras: ${alias_str})"
    return 0
  fi

  awk -v target_ip="$ip" -v target_host="$host" -v alias_str="$alias_str" '
  BEGIN{
    # normalize target_host (lowercase, strip trailing dot)
    th = tolower(target_host); sub(/\.$/, "", th)

    # track desired extra aliases (keyed by lowercase; store original form)
    split(alias_str, tmp, /[ \t]+/)
    for (i in tmp) {
      if (length(tmp[i])) {
        k = tolower(tmp[i]); sub(/\.$/, "", k)
        want[k] = tmp[i]
      }
    }

    N = 0
    host_line = 0
    ip_line = 0
  }

  # Parse and store all lines for a second-phase decision
  {
    orig = $0
    sub(/\r$/,"",orig)
    N++
    raw[N] = orig

    # default: passthrough line
    afters[N] = ""

    # Comments / blanks
    if (orig ~ /^[ \t]*#/ || orig ~ /^[ \t]*$/) next

    # split off trailing inline comment to preserve
    ci = index(orig, "#")
    if (ci > 0) { before = substr(orig, 1, ci-1); afters[N] = substr(orig, ci) }
    else        { before = orig;                          afters[N] = "" }

    # tokenize before-comment section
    n = split(before, f, /[ \t]+/)
    i0 = 1; while (i0 <= n && f[i0] == "") i0++
    if (i0 > n) next

    # first token is IP; store
    ips[N] = f[i0]

    # collect names (preserve order & original case)
    k = 0
    delete seen; delete order; delete order_lc
    for (i = i0+1; i <= n; i++) {
      if (f[i] == "") continue
      key = tolower(f[i]); sub(/\.$/, "", key)
      if (!(key in seen)) {
        seen[key] = 1
        k++
        order[k] = f[i]
        order_lc[k] = key
      }
    }
    counts[N] = k
    for (i = 1; i <= k; i++) names[N, i] = order[i]
    for (i = 1; i <= k; i++) names_lc[N, i] = order_lc[i]

    # Did we see the target host on this line?
    for (i = 1; i <= k; i++) {
      if (names_lc[N, i] == th) {
        if (host_line == 0) host_line = N
      }
    }

    # Remember first line with the target IP (for join-if-no-host case)
    if (ip_line == 0 && ips[N] == target_ip) ip_line = N
  }

  END{
    # CASE A: host already exists somewhere → update that line to target_ip (keep aliases, add extras)
    if (host_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == host_line) {
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          printf "%s", target_ip
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE B: host not present; there is a line with the same IP → add host (and extras) to that line
    if (ip_line > 0) {
      for (i = 1; i <= N; i++) {
        if (i == ip_line) {
          delete seen; for (j = 1; j <= counts[i]; j++) { key = tolower(names[i, j]); sub(/\.$/, "", key); seen[key] = 1 }

          printf "%s", ips[i]
          for (j = 1; j <= counts[i]; j++) printf " %s", names[i, j]

          if (!(th in seen)) printf " %s", target_host
          seen[th] = 1

          for (k in want) if (!(k in seen)) printf " %s", want[k]

          if (afters[i] != "") printf " %s", afters[i]
          printf "\n"
        } else {
          print raw[i]
        }
      }
      exit 0
    }

    # CASE C: no host, no same-IP line → append a new line at EOF
    for (i = 1; i <= N; i++) print raw[i]
    printf "%s %s", target_ip, target_host
    for (k in want) printf " %s", want[k]
    printf "\n"
  }
  ' /etc/hosts | sudo tee /etc/hosts >/dev/null
}

if [ "$#" -lt 2 ]; then
  echo "Usage: $0 OUTDIR IP [PORTS] [--dry-run] [--allow-regex '<regex>'] [--deny-file <path>] [--verbose]" >&2
  exit 2
fi

OUTDIR="$1"; IP="$2"
PORTS_ARG="${3:-}"

# shift off OUTDIR/IP; leave PORTS if present (we’ll re-read it from $3)
shift 2
ARGS=("$@")

ALLOW_REGEX=""
VERBOSE=0

# default deny file:
#   script location: lantern/scripts/add-hosts
#   deny list:       lantern/lists/deny-domains
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
DENY_FILE_DEFAULT="$SCRIPT_DIR/../lists/deny-domains"
DENY_FILE="${ADD_HOSTS_DENY:-$DENY_FILE_DEFAULT}"

# XML now comes from OUTDIR/report/
xml="$OUTDIR/report/targetedXML"
DOMAIN_RE='([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}'

# ---- load denylist file (optional) ----
DENY_PATTERNS=()
if [ -f "$DENY_FILE" ]; then
  while IFS= read -r line; do
    line="${line%%#*}"
    line="$(echo -n "$line" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
    [ -z "$line" ] && continue
    DENY_PATTERNS+=("$line")
  done < "$DENY_FILE"
else
  [ $VERBOSE -eq 1 ] && echo "[info] deny file not found: $DENY_FILE (no denylist applied)" >&2
fi

is_denied() {
  local host="$1" pat
  shopt -s nocasematch 2>/dev/null || true
  for pat in "${DENY_PATTERNS[@]}"; do
    if [[ "$host" =~ $pat ]]; then
      return 0
    fi
  done
  return 1
}

# Add one candidate hostname → map[name]=ip after all filters
add_candidate() {
  local nm="$1"
  local ip="$2"

  [[ -z "$nm" ]] && return 0
  nm="${nm%.}"   # drop trailing dot if any

  # require domain-ish token, skip bare IPs etc.
  if ! [[ "$nm" =~ $DOMAIN_RE ]]; then
    return 0
  fi

  [[ "$nm" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && return 0

  if [ -n "$ALLOW_REGEX" ] && ! [[ "$nm" =~ $ALLOW_REGEX ]]; then
    [ $VERBOSE -eq 1 ] && echo "[skip] $nm (allow-regex rejects)" >&2
    return 0
  fi
  if is_denied "$nm"; then
    [ $VERBOSE -eq 1 ] && echo "[deny] $nm (denylist)" >&2
    return 0
  fi

  [[ -z "${map[$nm]+x}" ]] && map["$nm"]="$ip"
}

# generic: scan a file for DOMAIN_RE tokens and add them
scan_file_for_domains() {
  local file="$1"
  local ip="$2"
  [ -s "$file" ] || return 0

  while IFS= read -r nm; do
    add_candidate "$nm" "$ip"
  done < <(grep -oE "$DOMAIN_RE" "$file" 2>/dev/null | sort -u)
}

declare -A map=()   # name -> ip

# ---------- 1a) Extract hostnames from XML (Nmap <hostnames>) ----------
if command -v xmlstarlet >/dev/null 2>&1; then
  if [ -s "$xml" ]; then
    while IFS= read -r line; do
      ippart="${line%% *}"
      namespart="${line#* }"
      [ -z "$ippart" ] && continue
      for nm in $namespart; do
        [[ -z "$nm" ]] && continue
        nm="${nm%.}"  # strip trailing dots
        add_candidate "$nm" "$ippart"
      done
    done < <(
      xmlstarlet sel -t -m "//host[status/@state='up']" \
        -v "address/@addr" -o " " \
        -m "hostnames/hostname" -v "@name" -o " " -b -n "$xml" 2>/dev/null \
      | sed -E 's/[[:space:]]+/ /g; s/ $//'
    )
  else
    [ $VERBOSE -eq 1 ] && echo "[info] XML file missing or empty: $xml" >&2
  fi
else
  [ $VERBOSE -eq 1 ] && echo "[info] xmlstarlet not installed; skipping Nmap hostname extraction" >&2
fi

# ---------- 1b) Extract FQDN-like tokens from Nmap script outputs ----------
# This is where we pick up things like "dc01.example.com" from smb-os-discovery, etc.
if command -v xmlstarlet >/dev/null 2>&1 && [ -s "$xml" ]; then
  while IFS= read -r line; do
    ippart="${line%% *}"
    payload="${line#* }"
    [ -z "$ippart" ] && continue
    [ -z "$payload" ] && continue

    while IFS= read -r nm; do
      add_candidate "$nm" "$ippart"
    done < <(printf '%s\n' "$payload" | grep -oE "$DOMAIN_RE" | sort -u || true)
  done < <(
    xmlstarlet sel -t \
      -m "//host[status/@state='up']" \
        -v "address/@addr" -o " " \
        -m ".//script" -v "@output" -o " " -b -n "$xml" 2>/dev/null \
    | sed -E 's/[[:space:]]+/ /g; s/ $//'
  )
fi

# ---------- 2) Harvest domains from HTTP artifacts under OUTDIR/report/http ----------
HTTP_ROOT="$OUTDIR/report/http"
if [ -d "$HTTP_ROOT" ]; then
  # Each port has its own dir: OUTDIR/report/http/<port>/
  while IFS= read -r portdir; do
    [ -d "$portdir" ] || continue

    # 2a) Headers (Location:, etc.) — just treat any header domains as candidates
    scan_file_for_domains "$portdir/headers.txt" "$IP"

    # 2b) Hosts extracted from body (hosts_from_body.txt)
    scan_file_for_domains "$portdir/hosts_from_body.txt" "$IP"

    # 2c) Certificate SANs from cert.txt (DNS: entries)
    cert_file="$portdir/cert.txt"
    if [ -s "$cert_file" ]; then
      while IFS= read -r nm; do
        add_candidate "$nm" "$IP"
      done < <(grep -oiE "DNS:$DOMAIN_RE" "$cert_file" 2>/dev/null \
               | sed -E 's/^DNS://I' \
               | sort -u)
    fi

  done < <(find "$HTTP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null || true)
fi

# --- 3) harvest domains from http-collected emails and verify via Host header ---
if [ -n "${PORTS_ARG:-}" ]; then
  email_domains_file="$(mktemp)"
  trap 'rm -f "$email_domains_file"' EXIT

  # web artifacts now live under OUTDIR/report/http
  while IFS= read -r ef; do
    [ -s "$ef" ] || continue
    awk -F'@' '{if (NF>=2) print $NF}' "$ef" \
      | tr 'A-Z' 'a-z' \
      | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' \
      >> "$email_domains_file"
  done < <(find "$HTTP_ROOT" -maxdepth 2 -type f -name 'emails.txt' 2>/dev/null || true)

  if [ -s "$email_domains_file" ]; then
    while IFS= read -r dom; do
      [[ -z "$dom" ]] && continue
      dom="${dom%.}"  # strip trailing dot

      verified_hit=0
      for p in $(echo "$PORTS_ARG" | tr ',' ' '); do
        p="${p//[^0-9]/}"; [ -z "$p" ] && continue
        if curl -sI --max-time 4 -H "Host: $dom" "http://$IP:$p/" \
          | head -n1 \
          | grep -qE 'HTTP/[0-9.]+\ [12][0-9]{2}|HTTP/[0-9.]+\ 3[0-9]{2}'; then
          verified_hit=1
          break
        fi
      done
      if [ "$verified_hit" -eq 1 ]; then
        add_candidate "$dom" "$IP"
      fi
    done < <(sort -u "$email_domains_file")
  fi
fi
# --- end email-domain verification ---

[ "${#map[@]}" -eq 0 ] && exit 0

for name in "${!map[@]}"; do
  ip="${map[$name]}"
  [[ "$name" =~ ^(localhost|ip6-localhost|ip6-loopback)$ ]] && continue
  [[ "$name" == "$ip" ]] && continue   # skip IP → IP noise

  if upsert_host_entry "$ip" "$name"; then
    [ "$DRY_RUN" -eq 0 ] && echo -e "${yellow}  [!]${end} ${blue}Ensured ${name} → ${ip}${end}"
  else
    echo -e "${red}ERROR: failed to upsert '${name}' into /etc/hosts (sudo?)${end}" >&2
    exit 1
  fi
done

exit 0
